\documentclass{article}

\usepackage{full page}  % make the margins somewhat smaller than the default
\usepackage{graphicx}    % needed for including graphics e.g. EPS, PS
\usepackage[]{algorithm2e}
\usepackage{mathtools}
\usepackage{listings}  % needed for source code listings
\lstset{language=Java}         

% set the document title, author, and date here.
%  once set, the \maketitle command (within the document)
%  will display them nicely
\title{Sphere Sampling in CSpace for Motion Planning}
\author{Yinan Zhang}

\begin{document}
\maketitle

\section{Introduction}

Traditionally, sampling based motion methods use discrete data to construct paths for motion tasks. The disadvantage of this kind of implementation is obvious: 

\begin{enumerate}
  \item CSpace is a continuous space, discrete samples cannot represent it well;
  \item Many samples are actually not necessary and consume a lot of memory, e.t. samples far away from obstacles.
  \item The way to get optimal path using samples in the free space requires building a dense roadmap, like PRM*.
\end{enumerate}

Our method is to sample spheres which contain collision-free area in configuration space. Using these hyper-spheres in c-space, we can:
\begin{enumerate}
  \item describe configuration space in a continuous way;
  \item find an optimal path;
  \item save memory by reducing unnecessary samples.
\end{enumerate}

\section{Sphere Sampling Algorithm}
\label{Sphere sampling algorithm}
 \begin{algorithm}
 	\KwData{Configuration Space}
 	\KwResult{Spheres that cover most of the free space}
 	s0 = sampleSphere( randomly position );\\
 	S = \{s0\}; \\
 	\tcp{Every two boundary points distance equals to $\delta$}
 	boundaryQueue = a queue that contains all boundary points of s0;\\
 	\While{ boundaryQueue is not empty }{
 		\tcp{Candidate point to sample next sphere.}
 		point = boundaryQueue.pop(); \\
 		\If{ point not in any spheres } {
 			si = sampleSphere( point );\\
 			\If{ $\delta$ $\leq$ si.radius } {
 				S = S $\cap$ \{si\}; \\
 				boundaryQueue.put( all boundary points of si ); 
 			}
 		}
 	}
 	\caption{ Sphere sampling algorithm }
 \end{algorithm}

	\subsection{Something we know}
                \subsunsection{How to interpret the algorithm? }
                        Our algorithm can be viewed as a combination of RRT and visibility-PRM. In each iteration of our algorithm, we get some more spheres center at the edge of existing ones, it rapidly and randomly grows until converge. Unlike RRT, these spheres build not only a tree rooted at the starting sphere, if we build the overlapping relationship of them, each sphere can also be viewed as a node of a roadmap. In a visibility PRM algorithm, if we limit the range a sample can view to a certain distance, or the distance from itself to the nearest obstacle, we can get pretty much the same result, which is why I view these spheres as a visibility roadmap. Inside each sphere, a robot is free to go anywhere without worrying about collision. 

		\subsubsection{Will the algorithm stop?}
 			\label{Finite number of spheres}
 			As is shown in the algorithm, we get boundary points of an existing sphere by limiting the distance between every two points to be equal to $\delta$. Then the algorithm samples new spheres centered at these points. So the distance between two spheres centers is always larger than or equal to $\delta$. 

 			The problem is equivalant to proof there could be finite number of points put in the space such that the distance between every two points is larger than or equal to $\delta$.

 			Assume we partition the whole configuration space( including free space and obstacle space ) into hyper-cubes. The length of every edge of these hyper-cubes is exactly $\delta$. As long as the configuration space has finite volume, the number of hyper-cubes is finite. Assume the number of hyper-cubes is N, the number of hyper-cubes that is totall or partly in free space is less than N. Thus the number of spheres is finite, and less than N.

 			So the algorithm will always converge.	

 		\subsubsection{$\delta$-clearance}
 			\cite{Karaman2011} proposed an algorithm, named PRM*, to find a path. It requires the actual optimal path to have $\delta$-clearance so the algorithm can find a approximately optimal path. Yet, the algorithm cannot explicitly control the quality of the path by defining $\delta$. In our alogrithm, we can define the actually value of $\delta$ and control the coverage of free-space by sampling spheres. 

 		\subsubsection{Find Containing Spheres}
 			In the algorithm, we need to know if a candidate point is inside any spheres. Naively, we need to iterate each existing spheres to determine if a point is inside, which requires O(n) time. This can fortunately be done with less time by hashing spheres to uniform grids of the c-space. Each grid contains references to spheres that intersect/contain the grid. By hasing a candidate point in the same way, we can easily know if a point is inside any spheres already.

 			(Can we use Locally Sensitive Hashing?)  

 		\subsubsection{Inaccurate matric}
			Suppose we have an inccurate matric which gives us the distance to obstacle:
 			dist[i] = accurate\_dist[i]/c[i], where 1 $\leq$ c[i] $\leq$ upper\_bound. When sampling at a point near the obstacle, dist[i] = accurate\_dist[i]/c[i] = $\delta$ the algorithm will stop sampling at that point. So the farthest distance from spheres boundary to obstacles is $\delta$ * upper\_bound. 

 			If the optimal path has $\delta$ * upper\_bound clearance. The algorithm can still cover the path and eventually find it.

                \subsubsection{How to fast determine if there exist a path between two configurations?}
                        One thing I like particularly about this methods is that it can fast determine if there exist a feasible path between two configurations. Usually in PRM* which builds a very dense roadmap, if we want to know whether there exists a path or not, we should run the A* search on the graph, by iterating all nodes in the graph, A* search will finally tell you it failed. It this case, A* search requires exponential time because it has to iterate all nodes in very depth of the graph. 
                        However, if we view the problem as finding a chain of spheres that contains start&goal configurations at the head&end of the chain, it will cost much less time to search the roadmap built by overlapping spheres. Because the number of spheres will be much less than the number of samples in a dense roadmap, and the number of edges is way less than a dense roadmap, which means even in the worst case, an exponential runtime will be much less than that required by A* searching a dense graph. 
   
                \subsubsection{How to deal with unlinked configuration space?}
                        A C-space can be partitioned into several parts by obstacles, each part is not linked to others, and there is not path from one part to another. 

	\subsection{Some Questions:}
 		\subsubsection{How to use less hyper-spheres to cover the space?}
 		\subsubsection{How to get the distance to obstacles more accurately?}

\section{A* search}


\begin{thebibliography}{9}

\bibitem{Karaman2011}
  Karaman, Sertac, and Emilio Frazzoli,
  \emph{"Sampling-based algorithms for optimal motion planning"}.
  The International Journal of Robotics Research 30.7 (2011): 846-894.
\end{thebibliography}




\end{document}
